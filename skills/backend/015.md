# 015. 微服务架构下的 API 网关设计

## 技能描述
掌握 API 网关在微服务架构中的核心作用，包括路由、认证、限流、监控和协议转换，构建统一的入口层。

## 核心知识点

### 1. API 网关的核心功能
- **请求路由**: 根据路径/方法转发到对应微服务
- **认证授权**: 统一处理 JWT/OAuth2 验证
- **限流熔断**: 防止过载，保护后端服务
- **日志监控**: 集中记录访问日志和指标
- **协议转换**: REST ↔ gRPC ↔ GraphQL
- **响应聚合**: 合并多个微服务的响应

### 2. 路由策略
- **路径路由**: `/api/users/*` → User Service
- **方法路由**: `GET /api/*` → Read Service, `POST /api/*` → Write Service
- **版本路由**: `/api/v1/*` vs `/api/v2/*`
- **权重路由**: 灰度发布，A/B 测试

### 3. 认证与授权
- **JWT 验证**: 网关层验证 Token，透传用户信息
- **OAuth2 集成**: 统一处理授权码流程
- **API Key 管理**: 为第三方开发者提供访问凭证
- **RBAC/ABAC**: 基于角色或属性的访问控制

### 4. 限流与熔断
- **限流算法**: 令牌桶、漏桶、滑动窗口
- **维度**: 按 IP、用户、API Key 限流
- **熔断器**: 快速失败，防止级联故障
- **降级策略**: 返回缓存数据或默认响应

### 5. 监控与可观测性
- **指标收集**: QPS、延迟、错误率
- **分布式追踪**: Trace ID 透传 (Jaeger, Zipkin)
- **日志聚合**: 结构化日志，集中存储
- **告警规则**: 异常检测和通知

## 实战示例

### 示例 1: Kong 网关配置
```yaml
services:
  - name: user-service
    url: http://user-svc:8080
    routes:
      - paths: [/api/users]
        methods: [GET, POST]

  - name: order-service
    url: http://order-svc:8080
    routes:
      - paths: [/api/orders]
        methods: [GET, POST]

plugins:
  - name: jwt
    config:
      key_claim_name: iss
      secret_is_base64: false

  - name: rate-limiting
    config:
      minute: 100
      policy: redis
      redis_host: redis.local

  - name: prometheus
    config:
      per_consumer: true
      status_code_metrics: true
```

### 示例 2: 自定义网关中间件 (Node.js + Express)
```javascript
// JWT 验证中间件
app.use('/api/*', async (req, res, next) => {
  const token = req.headers.authorization?.split(' ')[1];
  try {
    const payload = jwt.verify(token, process.env.JWT_SECRET);
    req.user = payload;
    next();
  } catch (err) {
    res.status(401).json({ error: 'Invalid token' });
  }
});

// 限流中间件
const limiter = rateLimit({
  windowMs: 60 * 1000, // 1 分钟
  max: 100, // 每 IP 最多 100 请求
  message: { error: 'Too many requests' }
});
app.use('/api/*', limiter);

// 路由转发
app.use('/api/users', createProxyMiddleware({ target: 'http://user-svc:8080' }));
app.use('/api/orders', createProxyMiddleware({ target: 'http://order-svc:8080' }));
```

### 示例 3: 响应聚合
```javascript
// 网关聚合用户信息和订单列表
app.get('/api/user-dashboard/:userId', async (req, res) => {
  const { userId } = req.params;
  
  const [user, orders, notifications] = await Promise.all([
    fetch(`http://user-svc/users/${userId}`),
    fetch(`http://order-svc/orders?user_id=${userId}`),
    fetch(`http://notify-svc/notifications?user_id=${userId}`)
  ]);
  
  res.json({
    user: await user.json(),
    orders: await orders.json(),
    notifications: await notifications.json()
  });
});
```

## 检查清单
- [ ] 实现请求路由到各微服务
- [ ] 集成 JWT/OAuth2 认证
- [ ] 配置限流规则 (按 IP/用户)
- [ ] 实现熔断和降级策略
- [ ] 添加分布式追踪 (Trace ID 透传)
- [ ] 收集 QPS、延迟、错误率指标
- [ ] 配置集中式日志记录
- [ ] 设置告警规则 (错误率 > 5% 等)
- [ ] 文档化所有网关路由规则

## 常见误区
- ❌ 网关承担过多业务逻辑 (应保持轻量)
- ❌ 忽略网关自身的水平扩展
- ❌ 没有透传 Trace ID，无法追踪
- ❌ 限流策略过于粗糙 (未区分 API 重要性)
- ❌ 网关单点故障 (未部署多实例)

## 参考资料
- [Kong Gateway](https://konghq.com/kong)
- [Envoy Proxy](https://www.envoyproxy.io/)
- [Spring Cloud Gateway](https://spring.io/projects/spring-cloud-gateway)
- [Microservices Patterns](https://microservices.io/patterns/index.html)
