# 014. GraphQL API 设计与实现

## 技能描述
掌握 GraphQL API 的设计原则、Schema 定义、Resolver 实现和性能优化技巧，构建灵活高效的 API。

## 核心知识点

### 1. GraphQL vs REST
- **REST**: 多端点，固定响应结构，可能过度/不足获取
- **GraphQL**: 单端点，客户端定义响应，精确获取所需数据
- **适用场景**: 复杂查询、多数据源聚合、移动端优化

### 2. Schema 定义语言 (SDL)
```graphql
type User {
  id: ID!
  name: String!
  email: String!
  posts: [Post!]!
  createdAt: DateTime!
}

type Post {
  id: ID!
  title: String!
  content: String!
  author: User!
  comments: [Comment!]!
}

type Query {
  user(id: ID!): User
  users(limit: Int = 10, offset: Int = 0): [User!]!
  post(id: ID!): Post
}

type Mutation {
  createUser(input: CreateUserInput!): User!
  updateUser(id: ID!, input: UpdateUserInput!): User!
  deleteUser(id: ID!): Boolean!
}

input CreateUserInput {
  name: String!
  email: String!
}

input UpdateUserInput {
  name: String
  email: String
}
```

### 3. Resolver 实现
```javascript
const resolvers = {
  Query: {
    user: async (_, { id }, { db }) => {
      return db.users.findById(id);
    },
    users: async (_, { limit, offset }, { db }) => {
      return db.users.find({ limit, offset });
    }
  },
  Mutation: {
    createUser: async (_, { input }, { db }) => {
      return db.users.insert(input);
    }
  },
  User: {
    posts: async (user, _, { db }) => {
      return db.posts.findByUserId(user.id);
    }
  }
};
```

### 4. 性能优化
- **DataLoader**: 解决 N+1 查询问题，批量加载数据
- **查询复杂度限制**: 防止恶意复杂查询
- **字段级缓存**: 缓存热点字段
- **持久化查询**: 预编译常用查询

### 5. 错误处理
- 标准错误格式：`errors: [{ message, locations, path }]`
- 自定义错误码和扩展信息
- 部分成功场景的处理

## 实战示例

### 示例 1: 客户端自定义查询
```graphql
query {
  user(id: "123") {
    name
    email
    posts {
      title
      createdAt
    }
  }
}
```

### 示例 2: 使用变量和片段
```graphql
query GetUser($userId: ID!, $includePosts: Boolean = false) {
  user(id: $userId) {
    name
    email
    posts @include(if: $includePosts) {
      ...PostFields
    }
  }
}

fragment PostFields on Post {
  id
  title
  content
}
```

### 示例 3: 突变操作
```graphql
mutation {
  createUser(input: { name: "张三", email: "zhangsan@example.com" }) {
    id
    name
    email
  }
}
```

## 检查清单
- [ ] 定义清晰的 Schema (类型、字段、关系)
- [ ] 实现所有 Query 和 Mutation 的 Resolver
- [ ] 使用 DataLoader 优化 N+1 查询
- [ ] 设置查询复杂度限制
- [ ] 实现标准化的错误处理
- [ ] 添加字段级权限控制
- [ ] 配置查询日志和监控
- [ ] 提供 GraphiQL/Playground 调试界面

## 常见误区
- ❌ 过度嵌套查询导致性能问题
- ❌ 忽略 N+1 查询问题
- ❌ 没有设置查询复杂度限制
- ❌ 错误处理不统一
- ❌ Schema 设计过于扁平或过于复杂

## 参考资料
- [GraphQL 官方文档](https://graphql.org/)
- [Apollo Server](https://www.apollographql.com/docs/apollo-server/)
- [GraphQL Best Practices](https://github.com/graphql/graphql-ws)
